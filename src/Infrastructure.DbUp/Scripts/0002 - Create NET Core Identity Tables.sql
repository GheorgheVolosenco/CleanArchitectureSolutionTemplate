CREATE SCHEMA IF NOT EXISTS "Identity";

-- Role
CREATE TABLE "Identity"."Role"
(
    id text NOT NULL,
    name character varying(256),
    normalized_name character varying(256),
    concurrency_stamp text,
    CONSTRAINT pk_role PRIMARY KEY (id)
);

CREATE UNIQUE INDEX "RoleNameIndex"
    ON "Identity"."Role" USING btree
    (normalized_name ASC NULLS LAST);

-- RoleClaims
CREATE TABLE "Identity"."RoleClaims"
(
    id integer NOT NULL GENERATED BY DEFAULT AS IDENTITY ( INCREMENT 1 START 1 MINVALUE 1 MAXVALUE 2147483647 CACHE 1 ),
    role_id text NOT NULL,
    claim_type text,
    claim_value text,
    CONSTRAINT pk_role_claims PRIMARY KEY (id),
    CONSTRAINT fk_role_claims_role_role_id FOREIGN KEY (role_id)
        REFERENCES "Identity"."Role" (id) MATCH SIMPLE
        ON UPDATE NO ACTION
        ON DELETE CASCADE
);

CREATE INDEX ix_role_claims_role_id
    ON "Identity"."RoleClaims" USING btree
    (role_id ASC NULLS LAST);

-- User
CREATE TABLE "Identity"."User"
(
    id text COLLATE pg_catalog."default" NOT NULL,
    first_name text COLLATE pg_catalog."default",
    last_name text COLLATE pg_catalog."default",
    user_name character varying(256) COLLATE pg_catalog."default",
    normalized_user_name character varying(256) COLLATE pg_catalog."default",
    email character varying(256) COLLATE pg_catalog."default",
    normalized_email character varying(256) COLLATE pg_catalog."default",
    email_confirmed boolean NOT NULL,
    password_hash text COLLATE pg_catalog."default",
    security_stamp text COLLATE pg_catalog."default",
    concurrency_stamp text COLLATE pg_catalog."default",
    phone_number text COLLATE pg_catalog."default",
    phone_number_confirmed boolean NOT NULL,
    two_factor_enabled boolean NOT NULL,
    lockout_end timestamp with time zone,
    lockout_enabled boolean NOT NULL,
    access_failed_count integer NOT NULL,
    CONSTRAINT pk_user PRIMARY KEY (id)
);

CREATE INDEX "EmailIndex"
    ON "Identity"."User" USING btree
    (normalized_email COLLATE pg_catalog."default" ASC NULLS LAST);

CREATE UNIQUE INDEX "UserNameIndex"
    ON "Identity"."User" USING btree
    (normalized_user_name COLLATE pg_catalog."default" ASC NULLS LAST);

-- UserClaims
CREATE TABLE "Identity"."UserClaims"
(
    id integer NOT NULL GENERATED BY DEFAULT AS IDENTITY ( INCREMENT 1 START 1 MINVALUE 1 MAXVALUE 2147483647 CACHE 1 ),
    user_id text COLLATE pg_catalog."default" NOT NULL,
    claim_type text COLLATE pg_catalog."default",
    claim_value text COLLATE pg_catalog."default",
    CONSTRAINT pk_user_claims PRIMARY KEY (id),
    CONSTRAINT fk_user_claims_user_user_id FOREIGN KEY (user_id)
        REFERENCES "Identity"."User" (id) MATCH SIMPLE
        ON UPDATE NO ACTION
        ON DELETE CASCADE
);

CREATE INDEX ix_user_claims_user_id
    ON "Identity"."UserClaims" USING btree
    (user_id COLLATE pg_catalog."default" ASC NULLS LAST)
    TABLESPACE pg_default;

-- UserLogins
CREATE TABLE "Identity"."UserLogins"
(
    login_provider text COLLATE pg_catalog."default" NOT NULL,
    provider_key text COLLATE pg_catalog."default" NOT NULL,
    provider_display_name text COLLATE pg_catalog."default",
    user_id text COLLATE pg_catalog."default" NOT NULL,
    CONSTRAINT pk_user_logins PRIMARY KEY (login_provider, provider_key),
    CONSTRAINT fk_user_logins_user_user_id FOREIGN KEY (user_id)
        REFERENCES "Identity"."User" (id) MATCH SIMPLE
        ON UPDATE NO ACTION
        ON DELETE CASCADE
);

CREATE INDEX ix_user_logins_user_id
    ON "Identity"."UserLogins" USING btree
    (user_id COLLATE pg_catalog."default" ASC NULLS LAST)
    TABLESPACE pg_default;

-- User Roles
CREATE TABLE "Identity"."UserRoles"
(
    user_id text COLLATE pg_catalog."default" NOT NULL,
    role_id text COLLATE pg_catalog."default" NOT NULL,
    CONSTRAINT pk_user_roles PRIMARY KEY (user_id, role_id),
    CONSTRAINT fk_user_roles_role_role_id FOREIGN KEY (role_id)
        REFERENCES "Identity"."Role" (id) MATCH SIMPLE
        ON UPDATE NO ACTION
        ON DELETE CASCADE,
    CONSTRAINT fk_user_roles_user_user_id FOREIGN KEY (user_id)
        REFERENCES "Identity"."User" (id) MATCH SIMPLE
        ON UPDATE NO ACTION
        ON DELETE CASCADE
);

CREATE INDEX ix_user_roles_role_id
    ON "Identity"."UserRoles" USING btree
    (role_id COLLATE pg_catalog."default" ASC NULLS LAST)
    TABLESPACE pg_default;

-- User Tokens
CREATE TABLE "Identity"."UserTokens"
(
    user_id text COLLATE pg_catalog."default" NOT NULL,
    login_provider text COLLATE pg_catalog."default" NOT NULL,
    name text COLLATE pg_catalog."default" NOT NULL,
    value text COLLATE pg_catalog."default",
    CONSTRAINT pk_user_tokens PRIMARY KEY (user_id, login_provider, name),
    CONSTRAINT fk_user_tokens_user_user_id FOREIGN KEY (user_id)
        REFERENCES "Identity"."User" (id) MATCH SIMPLE
        ON UPDATE NO ACTION
        ON DELETE CASCADE
);

-- refresh_token
CREATE TABLE "Identity".refresh_token
(
    id integer NOT NULL GENERATED BY DEFAULT AS IDENTITY ( INCREMENT 1 START 1 MINVALUE 1 MAXVALUE 2147483647 CACHE 1 ),
    token text COLLATE pg_catalog."default",
    expires timestamp without time zone NOT NULL,
    created timestamp without time zone NOT NULL,
    created_by_ip text COLLATE pg_catalog."default",
    revoked timestamp without time zone,
    revoked_by_ip text COLLATE pg_catalog."default",
    replaced_by_token text COLLATE pg_catalog."default",
    application_user_id text COLLATE pg_catalog."default",
    CONSTRAINT pk_refresh_token PRIMARY KEY (id),
    CONSTRAINT fk_refresh_token_users_application_user_id FOREIGN KEY (application_user_id)
        REFERENCES "Identity"."User" (id) MATCH SIMPLE
        ON UPDATE NO ACTION
        ON DELETE RESTRICT
);

CREATE INDEX ix_refresh_token_application_user_id
    ON "Identity".refresh_token USING btree
    (application_user_id COLLATE pg_catalog."default" ASC NULLS LAST)
    TABLESPACE pg_default;